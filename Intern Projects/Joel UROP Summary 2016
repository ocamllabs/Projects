I worked for Docker over the summer on a small tool to improve part of their workflow. They were generating lots of logs but could only view them in plain text, with all of the escape and control codes splurged out, making it unpleasant and difficult to read through. My task was to develop a simple OCaml library for formatting these logs as HTML, which could be integrated into their toolset.

It was a rocky start for me, however. Since the project was in OCaml I needed to have the environment set up on my computer. This turned out to be a major pain since I am, by no fault of my own, a Windows user. Initially I installed Cygwin and tried to install OPAM, but that was unsuccessful. I tried setting up Docker, but could not get Windows 10 Pro to install. Eventually I settled on using an Ubuntu VM, which was not ideal but did the trick. Later, I was lent a MacBook on which everything was a breeze! But all of this sapped away valuable time at the beginning, and meant I had to play catch-up later.

Once I had set up, OCaml was a pleasant experience to learn and use, for the most part. Throughout the project, its strong points of data types and pattern matching, polymorphic variants, modules, purity AND side-effects really shone. Because my task was largely about parsing, there was a lot of intermediate representation and it was nice to be able to deal with it in a lightweight and direct fashion, using types and pattern matching of course. The Angstrom parser combinator library was employed for the task of identifying escape codes amidst the text, while TyXml dealt with outputting HTML. Angstrom is fast and the code you write looks like the grammar production rules (as long as your grammar is LL) - and while it has support for Lwt and Async, I could not find a nice way to get incremental output, which would be very helpful performance-wise. The problem is, the logs are very large, and the parser cannot spit anything out until it has finished processing the chunk it has been fed. However, the HTML output complicates this picture as it is nested rather than a simple linear list structure, so it may not be so simple to output parts of the result one at a time. Other than this, though, the tool seems to behave as intended; it groups sequences of control codes up to the next RESET in the HTML and handles the most common types properly.

Further progress would center around this task of structuring the log files; e.g. identifying loading progress bars (===>25%, ===>30%, etc...) and omitting the previous steps or perhaps displaying it as an animation. Much of the structure that you'd want to add is very specific to the Docker workflows, so it'd definitely need to be done by someone who can properly understand the logs.

While the OCaml language and libraries are nice, I found its ecosystem very complicated. The build system can be difficult to grasp; after your first compilation you are presented with a ton of compiled files with mysterious extensions, and including dependencies is done via _tags files with their own structure. It would help for there to be more guides to the tools ocamlbuild, ocamlfind, topkg / oasis, opam, utop in less detail than their official documentation. The number of new names and concepts to get used to can be quite bewildering.
